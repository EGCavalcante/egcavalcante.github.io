<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Missão: Caça-Palavras</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    color: #343432;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 30px;
    margin: 0;
    min-height: 100vh;
  }
  
  h1 {
    color: #00827B;
    margin-bottom: 25px;
    text-align: center;
    font-size: 50px;
    font-weight: 700;
    text-shadow: 2px 2px 4px rgba(0, 130, 123, 0.1);
    letter-spacing: -1px;
  }
  
  #grid-container {
    background: #D3D3D3;
    padding: 20px;
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0, 130, 123, 0.15);
    border: 1px solid #000000;
    margin-bottom: 30px;
  }
  
  #grid {
    display: grid;
    gap: 1px;
    user-select: none;
    overflow: hidden;
    border: 1px solid #000000;
    background-color: #343432;
    touch-action: none;
  }
  
  .cell {
    background: #00827B;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-weight: 600;
    font-size: 16px;
    color: white;
    transition: all 0.2s ease;
    border: 1px solid #000000;
    text-transform: uppercase;
    position: relative;
  }
  
  .cell:hover:not(.selected):not(.found):not(.revealed) {
    background-color: #006b64;
    transform: scale(1.05);
  }
  
  .cell.selected {
    background-color: #343432;
    color: white;
    transform: scale(1.1);
    z-index: 10;
  }
  
  .cell.found {
    background-color: #ffffff;
    color: #006b64;
    font-weight: bold;
    animation: foundPulse 0.6s ease-out;
  }

  .cell.revealed {
    background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
    color: #856404;
    font-weight: bold;
  }
  
  @keyframes foundPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }
  
  #clues-section {
    margin-top: 20px;
    width: 100%;
    max-width: 800px;
  }
  
  #clues-section h2 {
    margin-bottom: 20px;
    color: #00827B;
    text-align: center;
    font-size: 32px;
    font-weight: 600;
    text-shadow: 1px 1px 2px rgba(0, 130, 123, 0.1);
  }
  
  #clues ul {
    list-style: none;
    padding: 0;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 15px;
    column-gap: 35px;
  }
  
  #clues li {
    background: white;
    padding: 16px 20px;
    border-radius: 12px;
    border-left: 5px solid #00827B;
    box-shadow: 0 4px 12px rgba(0, 130, 123, 0.1);
    font-size: 15px;
    /* margin-top: 20px; */
    position: relative;
    transition: all 0.3s ease;
    text-align: justify;
    line-height: 1.5;
  }
  
  #clues li:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 130, 123, 0.15);
  }
  
  #clues li.found {
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    border-left-color: #28a745;
    color: #155724;
  }
  
  #clues li.found::after {
    content: '✓';
    position: absolute;
    right: -25px;
    top: 50%;
    transform: translateY(-50%);
    color: #28a745;
    font-size: 24px;
    font-weight: bold;
  }
  
  #clues li.revealed {
    background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
    border-left-color: #ffc107;
    color: #856404;
  }
  
   
  .word-reveal {
    background: rgba(40, 167, 69, 0.1);
    color: #28a745;
    padding: 4px 8px;
    margin-left: 8px;
    border-radius: 6px;
    font-weight: 600;
  }
  
  .word-reveal.revealed-word {
    color: #856404;
    background: rgba(255, 193, 7, 0.2);
  }
  
  #found {
    margin-top: 25px;
    font-weight: 600;
    font-size: 18px;
    color: #00827B;
    text-align: center;
    padding: 12px 24px;
    background: white;
    border-radius: 25px;
    box-shadow: 0 4px 12px rgba(0, 130, 123, 0.1);
  }
  
  .button-container {
    margin-top: 25px;
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .action-button {
    padding: 12px 24px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    border-radius: 25px;
    background: linear-gradient(135deg, #00827B 0%, #006b64 100%);
    color: white;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 130, 123, 0.3);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .action-button:hover {
    background: linear-gradient(135deg, #006b64 0%, #005a54 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 130, 123, 0.4);
  }
  
  .action-button:active {
    transform: translateY(0);
  }

  @media (max-width: 768px) {
    h1 {
      font-size: 36px;
    }
    
    .cell {
      font-size: 14px;
    }
    
    #clues ul {
      grid-template-columns: 1fr;
    }
    
    #clues li {
      margin-bottom: 0;
    }
    
    .button-container {
      flex-direction: column;
      align-items: center;
    }
    
    .action-button {
      width: 200px;
    }
  }

  @media (max-width: 480px) {
    h1 {
      font-size: 28px;
    }
    
    #grid-container {
      padding: 15px;
    }
    
    .action-button {
      padding: 10px 20px;
      font-size: 14px;
      width: 180px;
    }
  }

  .footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: white;
    padding: 25px;
    margin-top: 40px;
    border-radius: 16px;
    width: 100%;
    max-width: 800px;
    box-shadow: 0 8px 32px rgba(0, 130, 123, 0.1);
    border: 2px solid rgba(0, 130, 123, 0.05);
  }

  .footer-left {
    flex: 0 0 auto;
  }

  .footer-image {
    max-width: 300px;
    height: auto;
  }

  .footer-right {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .footer-right a {
    display: flex;
    align-items: center;
    text-decoration: none;
    color: #343432;
    font-size: 16px;
    font-weight: 500;
    transition: all 0.3s ease;
    padding: 12px 16px;
    border-radius: 10px;
    min-width: 280px;
  }

  .footer-right img {
    width: 32px;
    height: 32px;
    margin-right: 15px;
  }

  .footer-right .youtube img {
    width: 48px;
    height: 32px;
  }

  .footer-right a:hover {
    background: linear-gradient(135deg, #00827B 0%, #006b64 100%);
    color: white;
    transform: translateX(5px);
  }

  @media (max-width: 768px) {
    .footer {
      flex-direction: column;
      text-align: center;
      gap: 20px;
    }
    
    .footer-right a {
      min-width: auto;
      justify-content: center;
    }
  }
</style>
</head>
<body>

<h1 id="game-title">Caça-palavras</h1>

<div id="grid-container">
  <div id="grid"></div>
</div>

<div id="clues-section">
  <h2>DICAS:</h2>
  <div id="clues">
    <ul></ul>
  </div>
</div>

<div class="button-container">
  <button id="resetBtn" class="action-button">Reiniciar Seleção</button>
  <button id="showAnswersBtn" class="action-button">Mostrar Respostas</button>
</div>

<div id="found"></div>

<script>
// CONFIGURAÇÃO DO JOGO - SUBSTITUA ESTA VARIÁVEL VIA N8N
let gameConfig = `{
  "title": "Malwares para Concursos",
  "gridSize": 18,
  "cellSize": 32,
  "words": [
    {
      "word": "MALWARE",
      "clue": "Termo genérico para software com intenção maliciosa."
    },
    {
      "word": "VÍRUS",
      "clue": "Programa que se anexa a outros para se replicar, necessitando de um hospedeiro."
    },
    {
      "word": "WORM",
      "clue": "Malware que se auto-replica e se espalha pela rede sem necessitar de um programa hospedeiro."
    },
    {
      "word": "TROJAN",
      "clue": "Tipo de malware que se disfarça de programa legítimo e útil para enganar o usuário."
    },
    {
      "word": "ROOTKIT",
      "clue": "Conjunto de programas que esconde a presença de um invasor e suas atividades no sistema."
    },
    {
      "word": "SPYWARE",
      "clue": "Software que coleta informações do usuário, como hábitos de navegação e dados pessoais, sem seu consentimento."
    },
    {
      "word": "ADWARE",
      "clue": "Programa que exibe anúncios indesejados no navegador ou sistema, muitas vezes de forma persistente."
    },
    {
      "word": "RAMSOMWARE",
      "clue": "Malware que criptografa arquivos importantes do usuário e exige pagamento para liberá-los."
    },
    {
      "word": "BOTNET",
      "clue": "Rede de computadores infectados (bots) controlados remotamente por um atacante para realizar ações maliciosas."
    },
    {
      "word": "BACKDOOR",
      "clue": "Abertura secreta em um sistema ou programa que permite acesso não autorizado e contorna mecanismos de segurança."
    },
    {
      "word": "KEYLOGGER",
      "clue": "Programa que registra e armazena todas as teclas digitadas pelo usuário, visando roubar informações sensíveis."
    },
    {
      "word": "EXPLOIT",
      "clue": "Código ou técnica que se aproveita de uma falha ou vulnerabilidade de segurança em um software ou sistema."
    },
    {
      "word": "PHISHING",
      "clue": "Técnica de fraude para obter dados confidenciais (senhas, números de cartão) através de engano, geralmente por e-mail ou sites falsos."
    },
    {
      "word": "CRIPTOMINER",
      "clue": "Malware que utiliza secretamente os recursos de processamento do computador da vítima para minerar criptomoedas."
    },
    {
      "word": "STEALER",
      "clue": "Tipo de malware projetado especificamente para roubar informações, como credenciais de login, dados bancários e outros arquivos sensíveis."
    }
  ]
}`
gameConfig = JSON.parse(gameConfig)
// Variáveis globais do jogo
let words = [];
let gridSize = 15;
let cellSize = 32;
let grid = [];
let placements = [];
let selection = [];
let foundWords = new Set();
let selectionDirection = null; // Armazena a direção estabelecida

// Elementos DOM
let gridElement = document.getElementById('grid');
const foundElement = document.getElementById('found');
const resetBtn = document.getElementById('resetBtn');
const showAnswersBtn = document.getElementById('showAnswersBtn');
const gameTitle = document.getElementById('game-title');

function updateGridStyles() {
  const responsiveCellSize = window.innerWidth <= 768 ? Math.max(25, cellSize - 7) : cellSize;
  
  gridElement.style.gridTemplateColumns = `repeat(${gridSize}, ${responsiveCellSize}px)`;
  gridElement.style.gridTemplateRows = `repeat(${gridSize}, ${responsiveCellSize}px)`;
  
  // Atualizar tamanho das células via CSS
  const style = document.createElement('style');
  style.textContent = `
    .cell {
      width: ${responsiveCellSize}px;
      height: ${responsiveCellSize}px;
    }
  `;
  document.head.appendChild(style);
}

function renderClues() {
  const cluesList = document.querySelector('#clues ul');
  cluesList.innerHTML = '';
  
  gameConfig.words.forEach((wordObj, index) => {
    const li = document.createElement('li');
    li.dataset.wordIndex = index;
    li.dataset.word = wordObj.word.toUpperCase();
    
    // Criar span para a dica
    const clueSpan = document.createElement('span');
    clueSpan.textContent = `${wordObj.clue} (${wordObj.word.length} letras)`;
    li.appendChild(clueSpan);
    
    // Se a palavra foi encontrada, adicionar classe e mostrar a palavra
    if (foundWords.has(wordObj.word.toUpperCase())) {
      li.classList.add('found');
      const wordSpan = document.createElement('span');
      wordSpan.className = 'word-reveal';
      wordSpan.textContent = `- ${wordObj.word.toUpperCase()}`;
      li.appendChild(wordSpan);
    }
    
    cluesList.appendChild(li);
  });
}

// Funções do jogo
function shuffle(array) {
  for(let i = array.length -1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const directions = [
  {x:1, y:0},   // horizontal direita
  {x:0, y:1},   // vertical baixo
  {x:1, y:1},   // diagonal direita-baixo
  {x:-1, y:1}   // diagonal esquerda-baixo
];

function placeWord(word) {
  const len = word.length;
  let tries = 200;
  while(tries--) {
    const dir = directions[Math.floor(Math.random()*directions.length)];
    
    const xLimit = (dir.x === 1) ? gridSize - len : (dir.x === -1) ? len - 1 : gridSize - 1;
    const yLimit = (dir.y === 1) ? gridSize - len : gridSize - 1;

    if (xLimit < 0 || yLimit < 0) continue;

    const xStart = Math.floor(Math.random() * (xLimit + 1));
    const yStart = Math.floor(Math.random() * (yLimit + 1));

    let canPlace = true;
    let path = [];

    for(let i=0; i<len; i++) {
      let xi = xStart + i*dir.x;
      let yi = yStart + i*dir.y;

      if (xi < 0 || xi >= gridSize || yi < 0 || yi >= gridSize) {
        canPlace = false;
        break;
      }

      let currentCellChar = grid[yi][xi];
      if(currentCellChar !== '' && currentCellChar !== word[i]) {
        canPlace = false;
        break;
      }
      path.push({x: xi, y: yi});
    }

    if(canPlace) {
      for(let i=0; i<len; i++) {
        grid[path[i].y][path[i].x] = word[i];
      }
      placements.push({word, positions: path});
      return true;
    }
  }
  return false;  
}

function fillEmpty() {
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  for(let y=0; y<gridSize; y++) {
    for(let x=0; x<gridSize; x++) {
      if(grid[y][x] === '') {
        grid[y][x] = letters.charAt(Math.floor(Math.random()*letters.length));
      }
    }
  }
}

function createGridData() {
  grid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(''));
  placements = [];

  const shuffledWords = shuffle([...words]); 
  for(let w of shuffledWords) {
    let placed = false;
    let tries = 0;
    while(!placed && tries < 10) {
      placed = placeWord(w.word.toUpperCase());
      tries++;
    }
    if(!placed) {
      console.warn('Não foi possível colocar a palavra:', w.word);
    }
  }
  fillEmpty();
}

function renderGrid() {
  gridElement.innerHTML = '';
  for(let y=0; y<gridSize; y++) {
    for(let x=0; x<gridSize; x++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.textContent = grid[y][x];
      cell.dataset.x = x;
      cell.dataset.y = y;
      gridElement.appendChild(cell);
    }
  }
  
  for (const foundWord of foundWords) {
    const placement = placements.find(p => p.word === foundWord);
    if (placement) {
      for (const pos of placement.positions) {
        const cell = Array.from(gridElement.children).find(c => +c.dataset.x === pos.x && +c.dataset.y === pos.y);
        if (cell) {
          cell.classList.add('found');
          cell.classList.remove('selected');
          cell.classList.remove('revealed');
        }
      }
    }
  }
}

function coordsEqual(a,b) {
  return a.x === b.x && a.y === b.y;
}

function isWordSelectionValid(selectionCoords) {
  const selectedText = selectionCoords.map(coord => grid[coord.y][coord.x]).join('');
  const selectedTextReversed = [...selectionCoords].reverse().map(coord => grid[coord.y][coord.x]).join('');

  for(let placement of placements) {
    if (foundWords.has(placement.word)) continue;

    const placedWord = placement.word;

    if (selectedText === placedWord || selectedTextReversed === placedWord) {
      if (placement.positions.length !== selectionCoords.length) continue;

      let selSorted = [...selectionCoords].sort((a,b)=>(a.x - b.x)|| (a.y - b.y));
      let posSorted = [...placement.positions].sort((a,b)=>(a.x - b.x)|| (a.y - b.y));

      let allEqual = true;
      for(let i=0; i<selSorted.length; i++) {
        if(!coordsEqual(selSorted[i], posSorted[i])) {
          allEqual = false;
          break;
        }
      }
      if(allEqual) {
        return placement.word;
      }
    }
  }
  return null;
}

function clearSelection() {
  selection = [];
  selectionDirection = null;
  document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
}

function updateFoundDisplay() {
  foundElement.textContent = `Palavras encontradas: ${foundWords.size} de ${words.length}`;
}

// Função auxiliar para calcular a direção normalizada
function normalizeDirection(dx, dy) {
  // Normaliza para -1, 0 ou 1
  const normX = dx === 0 ? 0 : dx / Math.abs(dx);
  const normY = dy === 0 ? 0 : dy / Math.abs(dy);
  return { x: normX, y: normY };
}

// Função para verificar se uma célula está alinhada com a seleção atual
function isAlignedWithSelection(newCell) {
  if (selection.length === 0) return true;
  if (selection.length === 1) {
    // Qualquer célula adjacente é válida para o segundo ponto
    const dx = Math.abs(newCell.x - selection[0].x);
    const dy = Math.abs(newCell.y - selection[0].y);
    return dx <= 1 && dy <= 1 && (dx > 0 || dy > 0);
  }
  
  // Para 3+ células, verificar se mantém a direção
  const firstCell = selection[0];
  const lastCell = selection[selection.length - 1];
  
  // Calcular a direção atual
  const currentDirX = lastCell.x - firstCell.x;
  const currentDirY = lastCell.y - firstCell.y;
  const currentDir = normalizeDirection(currentDirX, currentDirY);
  
  // Calcular a direção para a nova célula
  const newDirX = newCell.x - lastCell.x;
  const newDirY = newCell.y - lastCell.y;
  const newDir = normalizeDirection(newDirX, newDirY);
  
  // Verificar se a nova direção é consistente
  return currentDir.x === newDir.x && currentDir.y === newDir.y;
}

// Função para obter todas as células entre dois pontos
function getCellsBetween(start, end) {
  const cells = [];
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const steps = Math.max(Math.abs(dx), Math.abs(dy));
  
  if (steps === 0) return [start];
  
  const stepX = dx / steps;
  const stepY = dy / steps;
  
  for (let i = 0; i <= steps; i++) {
    const x = Math.round(start.x + stepX * i);
    const y = Math.round(start.y + stepY * i);
    cells.push({ x, y });
  }
  
  return cells;
}

function initializeGame() {
  // Aplicar configuração
  words = gameConfig.words.map((w, index) => ({
    word: w.word.toUpperCase(),
    clueIndex: index
  }));
  
  gridSize = gameConfig.gridSize;
  cellSize = gameConfig.cellSize || 32;
  
  // Atualizar título
  gameTitle.textContent = gameConfig.title;
  
  // Configurar grid CSS
  updateGridStyles();
  
  // Renderizar dicas
  renderClues();
  
  foundWords.clear();
  createGridData();
  renderGrid();
  updateFoundDisplay();
  
  // Atualizar a referência global do gridElement
  gridElement = document.getElementById('grid');
  
  // Event Listeners para o grid
  gridElement.replaceWith(gridElement.cloneNode(true));
  gridElement = document.getElementById('grid'); // Atualizar referência novamente
  
  let isSelecting = false;
  
  // Função para obter coordenadas de célula a partir de um ponto
  function getCellFromPoint(x, y) {
    const element = document.elementFromPoint(x, y);
    if (element && element.classList.contains('cell')) {
      return {
        x: +element.dataset.x,
        y: +element.dataset.y,
        element: element
      };
    }
    return null;
  }
  
  // Função melhorada para processar seleção
  function processSelection(cell) {
    if (!cell) return;
    
    const newCell = { x: cell.x, y: cell.y };
    
    // Se é a primeira célula, apenas adiciona
    if (selection.length === 0) {
      selection.push(newCell);
      cell.element.classList.add('selected');
      return;
    }
    
    // Se é a segunda célula, estabelece a direção
    if (selection.length === 1) {
      const dx = newCell.x - selection[0].x;
      const dy = newCell.y - selection[0].y;
      
      // Verifica se é adjacente (incluindo diagonais)
      if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && (dx !== 0 || dy !== 0)) {
        selectionDirection = normalizeDirection(dx, dy);
        selection.push(newCell);
        cell.element.classList.add('selected');
      }
      return;
    }
    
    // Para 3+ células: APENAS permite células que estejam EXATAMENTE na linha estabelecida
    const firstCell = selection[0];
    
    // Verifica se estamos voltando para uma célula já selecionada
    const existingIndex = selection.findIndex(s => s.x === newCell.x && s.y === newCell.y);
    if (existingIndex !== -1) {
      // Remove todas as células após esta
      for (let i = selection.length - 1; i > existingIndex; i--) {
        const cellToRemove = Array.from(gridElement.children).find(
          c => +c.dataset.x === selection[i].x && +c.dataset.y === selection[i].y
        );
        if (cellToRemove) {
          cellToRemove.classList.remove('selected');
        }
      }
      selection = selection.slice(0, existingIndex + 1);
      return;
    }
    
    // Verifica se a nova célula está EXATAMENTE alinhada com a direção estabelecida
    const dx = newCell.x - firstCell.x;
    const dy = newCell.y - firstCell.y;
    
    // Para estar na mesma linha:
    // - Horizontal: dy deve ser 0
    // - Vertical: dx deve ser 0  
    // - Diagonal: |dx| deve ser igual a |dy|
    
    let isAligned = false;
    
    if (selectionDirection.x === 0 && selectionDirection.y !== 0) {
      // Direção vertical - x deve ser o mesmo
      isAligned = newCell.x === firstCell.x;
    } else if (selectionDirection.x !== 0 && selectionDirection.y === 0) {
      // Direção horizontal - y deve ser o mesmo
      isAligned = newCell.y === firstCell.y;
    } else if (selectionDirection.x !== 0 && selectionDirection.y !== 0) {
      // Direção diagonal - |dx| deve ser igual a |dy|
      isAligned = Math.abs(dx) === Math.abs(dy);
      
      // Além disso, verifica se está na mesma diagonal (mesmo sinal)
      if (isAligned) {
        const expectedSignX = dx === 0 ? 0 : dx / Math.abs(dx);
        const expectedSignY = dy === 0 ? 0 : dy / Math.abs(dy);
        isAligned = expectedSignX === selectionDirection.x && expectedSignY === selectionDirection.y;
      }
    }
    
    if (isAligned) {
      // Preenche todas as células entre a última selecionada e a nova
      const lastCell = selection[selection.length - 1];
      const cellsBetween = getCellsBetween(lastCell, newCell);
      
      // Adiciona todas as células intermediárias
      for (let i = 1; i < cellsBetween.length; i++) {
        const betweenCell = cellsBetween[i];
        if (!selection.find(s => s.x === betweenCell.x && s.y === betweenCell.y)) {
          selection.push(betweenCell);
          const element = Array.from(gridElement.children).find(
            c => +c.dataset.x === betweenCell.x && +c.dataset.y === betweenCell.y
          );
          if (element) {
            element.classList.add('selected');
          }
        }
      }
    }
  }
  
  // Função para finalizar seleção
  function finishSelection() {
    if(selection.length > 0) {
      if(selection.length >= 3) {
        let foundWord = isWordSelectionValid(selection);
        if(foundWord) {
          foundWords.add(foundWord);
          const placement = placements.find(p => p.word === foundWord);
          if (placement) {
            for(let pos of placement.positions) {
              let cell = Array.from(gridElement.children).find(c=> +c.dataset.x === pos.x && +c.dataset.y === pos.y);
              if(cell) {
                cell.classList.add('found');
                cell.classList.remove('selected');
                cell.classList.remove('revealed');
              }
            }      
          }
          // Atualizar a lista de dicas para mostrar a palavra encontrada
          renderClues();
        }
      }
      clearSelection();
      updateFoundDisplay();
    }
    isSelecting = false;
  }
  
  // Mouse Events
  gridElement.addEventListener('mousedown', e => {
    if(!e.target.classList.contains('cell')) return;
    
    isSelecting = true;
    clearSelection();
    selection = [{x: +e.target.dataset.x, y: +e.target.dataset.y}];
    e.target.classList.add('selected');
    e.preventDefault();
  });

  gridElement.addEventListener('mouseover', e => {
    if(!isSelecting || selection.length === 0) return;
    if(!e.target.classList.contains('cell')) return;
    
    const cell = {
      x: +e.target.dataset.x,
      y: +e.target.dataset.y,
      element: e.target
    };
    
    processSelection(cell);
  });

  window.addEventListener('mouseup', e => {
    if (isSelecting) {
      finishSelection();
    }
  });
  
  // Touch Events para mobile
  gridElement.addEventListener('touchstart', e => {
    e.preventDefault(); // Previne scroll
    
    const touch = e.touches[0];
    const cell = getCellFromPoint(touch.clientX, touch.clientY);
    
    if(!cell) return;
    
    isSelecting = true;
    clearSelection();
    selection = [{x: cell.x, y: cell.y}];
    cell.element.classList.add('selected');
  }, { passive: false });

  gridElement.addEventListener('touchmove', e => {
    e.preventDefault(); // Previne scroll
    
    if(!isSelecting || selection.length === 0) return;
    
    const touch = e.touches[0];
    const cell = getCellFromPoint(touch.clientX, touch.clientY);
    
    if(cell) {
      processSelection(cell);
    }
  }, { passive: false });

  gridElement.addEventListener('touchend', e => {
    e.preventDefault(); // Previne comportamentos padrão
    
    if (isSelecting) {
      finishSelection();
    }
  }, { passive: false });
  
  // Prevenir context menu no mobile
  gridElement.addEventListener('contextmenu', e => {
    e.preventDefault();
  });
}

// Event Listeners
resetBtn.addEventListener('click', () => {
  initializeGame();
  document.querySelectorAll('.cell.revealed').forEach(c => {
    c.classList.remove('revealed');
  });
});

showAnswersBtn.addEventListener('click', () => {
  // Usar o elemento grid atual, não a referência antiga
  const currentGrid = document.getElementById('grid');
  for (let placement of placements) {
    if (!foundWords.has(placement.word)) {
      for (let pos of placement.positions) {
        let cell = Array.from(currentGrid.children).find(c => +c.dataset.x === pos.x && +c.dataset.y === pos.y);
        if (cell) {
          cell.classList.add('revealed');
        }
      }
    }
  }
  
  // Mostrar todas as palavras nas dicas quando revelar respostas
  gameConfig.words.forEach(wordObj => {
    const wordUpper = wordObj.word.toUpperCase();
    const li = document.querySelector(`li[data-word="${wordUpper}"]`);
    
    if (li) {
      // Se a palavra não foi encontrada pelo jogador
      if (!foundWords.has(wordUpper)) {
        // Adicionar classe revealed em vez de found
        li.classList.add('revealed');
        
        // Adicionar a palavra se ainda não estiver lá
        if (!li.querySelector('.word-reveal')) {
          const wordSpan = document.createElement('span');
          wordSpan.className = 'word-reveal revealed-word';
          wordSpan.textContent = `- ${wordUpper}`;
          li.appendChild(wordSpan);
        }
      }
    }
  });
});

// Responsividade
window.addEventListener('resize', () => {
  updateGridStyles();
});

// Inicialização
initializeGame();

</script>
<div class="footer">
  <div class="footer-left">
    <img src="./logo.png" alt="Logo" class="footer-image">
  </div>
  
  <div class="footer-right">
    <a href="https://chat.whatsapp.com/FPoPWLX32BTDM7decA4MUn" target="_blank">
      <img src="./whatsapp.png"> Entre no nosso grupo de estudos!
    </a>
    <a href="https://www.instagram.com/prof.eduardocavalcante/" target="_blank">
      <img src="./instagram.png"> Instagram
    </a>
    <a class="youtube" href="https://www.youtube.com/@prof.eduardocavalcante" target="_blank">
      <img src="./youtube.png"> YouTube
    </a>
    <a href="https://www.profeduardocavalcante.com.br" target="_blank">
      <img src="./website.png"> Site
    </a>
  </div>
</div>

</body>
</html>